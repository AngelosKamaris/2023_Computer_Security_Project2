## 2023 Project 2

Ο στόχος σας είναι να επιτεθείτε στον server `project-2.csec.chatzi.org`.
Γνωρίζετε ότι στο url http://project-2.csec.chatzi.org:8000
τρέχει o pico webserver, ο κώδικας του οποίου
υπάρχει στο [πακάτω repository](https://github.com/chatziko/pico).
Εχετε επίσης ήδη υποκλέψει:
- το username του site: `admin`
- το password: `8c6e2f34df08e2f879e61eeb9e8ba96f8d9e96d8033870f80127567d270d7d96`  
  (ο συγκεκριμένος webserver το δέχεται μόνο σε encrypted μορφή)

Tasks:

1. Βρείτε το MD5 digest του plaintext password
1. Βρείτε το plaintext password
1. Βρείτε το περιεχόμενο του αρχείου `/etc/secret` στον server
1. Βρείτε το αποτέλεσμα της εντολής `lspci` στον server




### Παρατηρήσεις

- Οι ίδιες ομάδες με την εργασία 1
- Εγγραφή στο github: https://classroom.github.com/a/HxmDkdtS

- Η ταχύτητα επίλυσης __δεν__ έχει βαθμολογική σημασία, αλλά θα υπάρχει "leaderboard"
  με τους 3 πρώτους που λύνουν κάθε task καθαρά για λόγους "flexing". Αν είστε στους
  πρώτους στείλτε claim στο `ys13@chatzi.org` (αλλιώς δεν χρειάζεται).

- Τα βήματα μπορούν να λυθούν με οποιαδήποτε σειρά, δεν χρειάζεται
  η λύση του ενός για το επόμενο (αλλά προτείνεται η σειρά που δίνεται).

- Hints:
  - Task 1: πρέπει να χρησιμοποιήσετε μια απλή ευπάθεια στον C κώδικα
  - Task 2: πρέπει να σπάσετε το encryption χρησιμοποιώντας μια ευπάθεια της υλοποίησης. __Δεν__
       πρέπει να κάνετε invert το digest από το task 1 (δεν θα το βρείτε
       σε MD5 databases, εκτός και αν κάποια άλλη ομάδα το βρει και το προσθέσει).
  - Tasks 3/4: buffer overflow attack. Το attack στο task 4 είναι λίγο πιο δύσκολο (αν θέλετε μπορείτε να κάνετε τα δύο tasks μαζί, αλλά στο 3 υπάρχει και λίγο πιο εύκολη λύση).

- Βαθμολογία μαθήματος
    - Εργασία 1: 4 μονάδες
    - Εργασία 2:
      - Task 1: 1 μονάδα
      - Task 2: 1 μονάδα
      - Task 3: 2 μονάδες
      - Task 4: 1 μονάδα
      - Docker: 1 μονάδα

- Στο τέλος του `README.md`: αναφέρετε τις απαντήσεις, και περιγράψτε τα βήματα που ακολουθήσατε. Μην ξεχάσετε να κάνετε commit μαζί με οποιοδήποτε κώδικα χρησιμοποιήσατε.
    Για ό,τι δεν ολοκληρώσετε περιγράψτε (και υλοποιήστε στο πρόγραμμα) την πρόοδό σας και πώς θα μπορούσατε να συνεχίσετε.

- Για όλα τα βήματα απαιτείται να γράψετε ένα πρόγραμμα που να αυτοματοποιεί την εύρεση της λύσης.
  Μπορείτε να χρησιμοποιήσετε ό,τι γλώσσα προγραμματισμού θέλετε, αλλά θα πρέπει να μπορώ να το τρέξω
  σε Ubuntu 22.04 χρησιμοποιώντας software που είναι διαθέσιμο στο Ubuntu. Θα πρέπει επίσης
  να φτιάξετε ένα script `run.sh` που εκτελεί το πρόγραμμα με ό,τι παραμέτρους χρειάζονται.

- Η πλήρης λύση της εργασίας απαιτεί να φτιάξετε ένα Docker container που να αυτοματοποιεί πλήρως την επίθεση. Ένα script ουσιαστικά, που απλά να εκτελείται σε container
ώστε να μπορεί να τρέξει οπουδήποτε. Πάραδειγμα `Dockerfile` υπάρχει στο repository,
και θα πρέπει να τρέχει με:
  ```
  docker build --tag attack . && docker run attack
  ```
  Λύσεις χωρίς docker γίνονται δεκτές, απλά χάνετε 1 μονάδα.

- Deadline: __20/7__ (μέχρι το τέλος της ημέρας)
  - Μπορείτε να παραδώσετε την εργασία και το Σεπτέμβρη, με μόνη διαφορά
  ότι το docker τότε θα πιάνει 3 μονάδες γιατί έχετε παραπάνω χρόνο
  (και πάλι όμως μπορείτε να πάρετε 10).

- __Οχι spoilers__

- __Οχι DoS__ ή brute force. Μπορείτε να χρησιμοποιείτε scripts που να κάνουν μια επίθεση με έναν λογικό αριθμό από requests (να μπορεί να τελειώσει σε μία ώρα max). Aλλά όποιος βαράει στα τυφλά μηδενίζεται
   (θέλουμε οι servers να είναι accessible από όλους). Αν δεν είστε σίγουροι αν κάτι επιτρέπεται, απλά ρωτήστε.

- Είναι σαφώς προτιμότερο να υλοποιήσετε πρώτα όλα τα attacks locally πριν τα τρέξετε στον server.

- Ο pico server έχει γίνει compile στο `linux03.di.uoa.gr`, οπότε μπορείτε εκεί να φτιάξετε
  ένα executable ακριβώς σαν αυτό που εκτελείται στον server.

- Αν θέλετε hints ρωτήστε privately (χωρίς βαθμολογική συνέπεια, σε λογικά πλαίσια).




### Report

Προς συμπλήρωση:

Απαντήσεις:
1. Απάντηση: ef281a07091268a0d779cf489d00380c

 Αφού ανοίξαμε την σελίδα στο ίντερνετ και κοιτάξαμε μήπως υπήρχε τίποτα στο περιεχόμενό της, αποφασίσαμε να δούμε τον κώδικα από το pico repository που μας δινόταν από την εργασία. Εκεί είδαμε ότι αν κάναμε ένα post με Aythorization Basic στον server, αυτός θα πήγαινε σε μια συνάρτηση η οποία λέγεται check_auth, η οποία δέχεται ένα string μετά την Basic της μορφής <username>:<encrypted-password> και ελέγχει αν ο χρήστης είναι σε μια λίστα χρηστών,και αν υπάρχει σώζει τον κωδικό του σε μια μεταβλητή που κρατάει τους md5 κωδικούς των χρηστών, αν αυτή η μεταβλητή παραμείνει άδεια σημαίνει οτι ο χρήστης δεν υπάρχει και εκτυπώνει το όνομα του χρήστη λέγοντας πως είναι invalid. Αλλιώς ελέγχει αν ο κωδικός είναι σωστός.

Εμείς λοιπόν πήγαμε να κάνουμε make τον κώδικα του pico και μας βγάζει warning:
format not a string literal and no format arguments [-Wformat-security]
  127 |     printf(auth_username);

  Βλέποντάς το αυτό αναζητήσαμε γιατί μας βγάζει αυτό το warning και βρήκαμε ότι αυτή η μέθοδος εκτύπωσης του ονόματος είναι ευάλωτη. Συγκεκριμένα έχουμε Format String Vulnerability. Αυτό σημαίνει ότι αυτή η printf δεν φιλτράρει το όνομα του χρήστη πριν το εκτυπώσει και έτσι ένας χρήστης μπορεί να βάλει μεταβλητές όπως %x, %s, για να εκτυπώσει το περιεχόμενο της στοίβας. Γνωρίζουμε ότι το όνομα και ο md5-κωδικός είναι στην στοίβα, καθώς είναι το πρώτο όρισμα της συνάρτησης check_auth, και αφού γνωρίζουμε ήδη το περιεχόμενο της Line user[], στον pico που είναι test:098f6bcd4621d373cade4e832627b4f6, θα περάσω στον header authority μετά το basic ένα string που τα κατάλληλα %x και ένα %s για να εμφανιστεί η μεταβλητή.Αυτό μας δίνει το string: JXgleCV4JXgleCV4ICAgLSAgICVz, που αν το κάνουμε base64 decode είναι το %x%x%x%x%x%x   -   %s, το οποίο βγάζει σαν αποτέλεσμα στην κλήση του από  το attack.py στον φάκελο 1 οπού βρίσκεται και το script που τρέξαμε,
  Error: {'WWW-Authenticate': 'Basic realm="Invalid user: 56d75330155663e94bf7a7ada0f79f438056d653df   -   test:098f6bcd4621d373cade4e832627b4f6"'}, όπου τα δεδομένα 
  μετά την - έχουν το όνομα και την md5 μορφή του κωδικού.

   Αφού πέτυχε λοιπόν στον τοπικό μου σέρβερ δοκίμασα την ίδια επίθεση και στον κανονικό από όπου πήρα αποτέλεσμα:

   Error: {'WWW-Authenticate': 'Basic realm="Invalid user: 57deb330155658fcdff7cc7d20f7c5238057ddb3ef   -   admin:ef281a07091268a0d779cf489d00380c"'},
    άρα ο md5 password είναι ο: ef281a07091268a0d779cf489d00380c
   

2.Απάντηση: aCEDIsRateRe
  
Στο δεύτερο ερώτημα εφαρμόζουμε το padding oracle attack που βρήκαμε εδώ, έχοντας κάνει κατάλληλες αλλαγές για να τρέχει στον server: https://github.com/TheCrowned/padding-oracle-attack.

  Κοιτόντας τον κώδικα του φακέλου encryption, μπορούμε να διακρίνουμε ότι η μέθοδος που χρησιμοποιήται για το encryption των κωδικώνείναι AES, CBC χρησιμοποιώντας για padding pkcs7. Αυτή η μέθοδος γνωρίζουμε ότι χωρίζει το μύνημα σε block των 16 byte και ξεκινάει χρησιμοποιώντας για αρχή ένα IV(σε αυτή την περίπτωση ένα block γεμάτο 0) και κάνει xor το πρώτο μπλοκ με το IV και ύστερα το κάνει eνcrypt με το κλειδί. Δημιουργεί έτσι το πρώτο block του ciphertext. Ύστερα χρησιμοποιεί το πρώτο block του ciphertext για να κάνει xor το δεύτερο block του plaintext, το οποίο κάνει eνcrypt για να δημιουργήσει το 2ο block ciphertext και αυτό επαναλαμβάνεται εως ότου να φτάσει στο τελευταίο block. Για να πετύχει αυτό όμως πρέπει το plaintext να έχει μέγεθος πολλαπλάσιο του 16, κάτι το οποίο για να το επιτύχει, προσθέτει padding στο τέλος των block της μορφής 0, 1, 22, 333 ,..., 255*255.

  Αυτό μπορεί να κάνει το πρόγραμμα πολύ ευάλωτο σε περίπτωση που έχουμε έναν τρόπο να μάθουμε αν ο κωδικός που δώσαμε έχει θέμα με το padding. Κοιτόντας τον κώδικα λοιπόν, μπορούμε να δούμε ότι όταν υπάρχει θέμα με το padding, η συνάρτηση decrypt επιστρέφει null, κάτι το οποίο οδηγεί στην αποστολή ERROR 500 στον χρήστη, το οποίο δεν εμφανίζεται όταν ο χρήστης έχει απλά λάθος κωδικό ή έχει συνδεθεί σωστά (401, 200). Επομένως βάζοντας σαν oracle μια συνάρτηση που κάνει request στον server, δίνοντας ένα ciphertext τροποποιημένο κατάλληλα ωστε να ισχύουν αυτά που θα πω μετά, και επιστρέφοντας λάθος όταν έχω status 500, μπορώ να κάνω padding oracle attack.

  Η επίθεσή μου εκμεταλλεύεται το γεγονός ότι ισχύει  a (xor) b = c <=> a (xor) c = b και αφού C1 XOR P2 = P2', όπου P2'  είναι το block2 πριν το encryption, C1 είναι το ciphertext 1 και P2 είναι το plaintext 2. Έτσι εμείς αν έχουμε 2 block, θα πηγαίναμε στο block 1 και θα δοκιμάζαμε paddings μέχρι να έχουμε το σωστό. Έτσι μπορούμε να μάθουμε το τελευτταίο byte του P2, κάνοντας xor με το padding από το C1, και να το επαναλάβουμε αυτό από το πρότελευταίο εως το πρώτο byte του P2, ώστε να πάρουμε το P2 ολόκληρο. αν επαναλάβουμε αυτό για κάθε μπλοκ, τότε θα έχουμε το plaintext σε λιγότερο από 4096 προσπάθειες ανα block, κάτι το οποίο είναι πιο γρήγορο από τις 2^128 προσπάθειες ανα block που θα χρειαζόμασταν για να σπάσουμε το ciphertext.
  
4. 
5. ...
6. ...

...
